"""
Input models for onboarding tools.

This module defines Pydantic models for validating onboarding tool inputs.
These models provide type-safe validation and consistent error messages.

Includes:
- World Seed Generator models (StatDefinition, StatSystem, InventoryItem, etc.)
- CompleteOnboardingInput for phase transition
- PersistWorldSeedInput for world seed persistence

Note: These models are for internal validation only. YAML configurations
remain the source of truth for tool schemas shown to Claude.
"""

from __future__ import annotations

from typing import Any

from pydantic import BaseModel, Field, field_validator

# =============================================================================
# Shared Models (used by multiple tools)
# =============================================================================


class StatDefinition(BaseModel):
    """A single stat definition for the game world."""

    name: str = Field(..., description="Internal stat name (e.g., 'health', 'mana')")
    display: str = Field(..., description="Display name shown to player (e.g., 'HP', 'MP')")
    min: int | None = Field(0, description="Minimum value (default: 0)")
    max: int | None = Field(100, description="Maximum value (null for unlimited)")
    default: int = Field(..., description="Starting value for new players")
    color: str | None = Field(None, description="Optional hex color for UI (e.g., '#ff0000')")


class StatSystem(BaseModel):
    """Complete stat system definition."""

    stats: list[StatDefinition] = Field(..., description="List of stat definitions", min_length=1)
    derived: list[dict[str, Any]] | None = Field(
        default_factory=list, description="Optional derived stats (computed from base stats)"
    )


class InitialLocation(BaseModel):
    """First location where the player starts."""

    name: str = Field(..., description="Location slug (e.g., 'abandoned_watchtower')")
    display_name: str = Field(..., description="Human-readable name (e.g., 'Abandoned Watchtower')")
    description: str = Field(..., description="Rich description of the location (2-3 paragraphs)")
    position_x: int = Field(0, description="X coordinate on map")
    position_y: int = Field(0, description="Y coordinate on map")
    adjacent_hints: list[str] | None = Field(default_factory=list, description="Names of nearby locations to hint at")


class InventoryItem(BaseModel):
    """An item in the player's inventory or an item template.

    Used both for:
    - Starting inventory items (with quantity)
    - Item templates via persist_new_item (quantity defaults to 1)
    """

    item_id: str = Field(..., description="Unique item identifier (snake_case recommended)")
    name: str = Field(..., description="Display name")
    description: str | None = Field(None, description="Item description")
    quantity: int = Field(1, description="Number of this item (default: 1)")
    properties: dict[str, Any] | None = Field(default_factory=dict, description="Custom properties")

    @field_validator("item_id", mode="before")
    @classmethod
    def validate_item_id(cls, v: str | None) -> str:
        """Ensure item_id is provided, stripped, and filesystem-safe."""
        if v is None:
            raise ValueError("Item ID is required")
        v = str(v).strip()
        if not v:
            raise ValueError("Item ID cannot be empty")
        # Sanitize for filesystem safety
        safe_chars = set("abcdefghijklmnopqrstuvwxyz0123456789_-")
        if not all(c in safe_chars for c in v.lower()):
            raise ValueError("Item ID must contain only alphanumeric characters, underscores, and hyphens")
        return v

    @field_validator("name", mode="before")
    @classmethod
    def validate_name(cls, v: str | None) -> str:
        """Ensure name is provided and stripped."""
        if v is None:
            raise ValueError("Item name is required")
        v = str(v).strip()
        if not v:
            raise ValueError("Item name cannot be empty")
        return v

    @field_validator("description", mode="before")
    @classmethod
    def strip_description(cls, v: str | None) -> str | None:
        """Strip whitespace and handle None values."""
        if v is None:
            return None
        return str(v).strip() or None


# =============================================================================
# World Seed Generator Models
# =============================================================================


class WorldSeed(BaseModel):
    """
    Complete world seed generated by World Seed Generator.

    This is the structured output that World Seed Generator produces
    after Onboarding Manager completes the initial setup.
    """

    stat_system: StatSystem = Field(..., description="The stat system for this world")
    initial_location: InitialLocation = Field(..., description="Starting location details")
    initial_stats: dict[str, int] | None = Field(
        None, description="Override starting stat values (uses defaults if not provided)"
    )
    initial_inventory: list[InventoryItem] | None = Field(
        default_factory=list, description="Starting items for the player"
    )
    world_notes: str | None = Field(None, description="Additional notes about the world for other agents")


class PersistWorldSeedInput(WorldSeed):
    """
    Input model for persist_world_seed tool.

    Extends WorldSeed with world_name, which is required to know
    where to persist the world seed data.
    """

    world_name: str = Field(..., description="The world name to persist the seed to")


# =============================================================================
# Onboarding Complete Tool Input
# =============================================================================


class CompleteOnboardingInput(BaseModel):
    """Input for complete onboarding tool.

    Used by Onboarding Manager to finalize world setup and transition
    from onboarding phase to active gameplay.
    """

    genre: str = Field(
        ...,
        min_length=1,
        description="World genre (e.g., 'dark fantasy', 'sci-fi horror', 'cozy mystery')",
    )
    theme: str = Field(
        ...,
        min_length=1,
        description="Thematic elements (e.g., 'survival and redemption', 'political intrigue')",
    )
    lore: str = Field(
        ...,
        min_length=100,
        description="""Comprehensive world lore (8-15 paragraphs) that establishes:

**Foundation Layer:**
- Origin/creation myth or historical foundation
- Core metaphysics (how magic/technology/power works and its costs)
- Geography overview (continents, key regions, climate)

**Power & Society:**
- Major factions, nations, or organizations and their tensions
- Social hierarchy and class dynamics
- Economy basics (what's valuable, trade, currency)

**Current State:**
- Recent history (past 50-100 years of major events)
- The current crisis, tension, or situation driving the world
- Where power currently sits and who threatens it

**Culture & Daily Life:**
- Dominant religions, philosophies, or belief systems
- Common people's lives, fears, and aspirations
- Taboos, laws, or cultural practices that shape behavior

**Mystery & Wonder:**
- Unexplained phenomena or ancient mysteries
- Legendary places, artifacts, or figures
- What the world whispers about but doesn't understand

The lore should feel lived-inâ€”specific names, places, and details that make it tangible. Include at least 3-5 proper nouns (people, places, organizations) that the player might encounter.""",
    )
    player_name: str = Field(
        ...,
        min_length=1,
        description="The name the player wants to be called in the world",
    )

    @field_validator("genre", "theme", "player_name", mode="before")
    @classmethod
    def validate_required_string(cls, v: str | None) -> str:
        """Ensure required string fields are provided and stripped."""
        if v is None:
            raise ValueError("Field is required")
        v = str(v).strip()
        if not v:
            raise ValueError("Field cannot be empty")
        return v

    @field_validator("lore", mode="before")
    @classmethod
    def validate_lore(cls, v: str | None) -> str:
        """Ensure lore is provided, stripped, and has substantial content."""
        if v is None:
            raise ValueError("Lore is required")
        v = str(v).strip()
        if not v:
            raise ValueError("Lore cannot be empty")
        if len(v) < 100:
            raise ValueError("Lore must be at least 100 characters")
        return v

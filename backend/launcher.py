"""
Launcher script for the packaged ClaudeWorld application.

This is the entry point for the PyInstaller bundle. It:
1. Sets up paths for bundled resources
2. Runs first-time setup wizard if needed
3. Starts the uvicorn server
4. Opens a native window (pywebview) or falls back to the browser
"""

import getpass
import os
import secrets
import shutil
import subprocess
import sys
import threading
import time
import webbrowser
from pathlib import Path
from threading import Timer

# Server configuration
HOST = "127.0.0.1"
PORT = 8000
SERVER_URL = f"http://{HOST}:{PORT}"


def get_base_path() -> Path:
    """Get the base path for resources (handles both dev and bundled modes)."""
    if getattr(sys, "frozen", False):
        # Running as PyInstaller bundle
        return Path(sys._MEIPASS)
    else:
        # Running in development
        return Path(__file__).parent.parent


def get_work_dir() -> Path:
    """Get the working directory for user data (.env, agents, etc.)."""
    if getattr(sys, "frozen", False):
        return Path(sys.executable).parent
    else:
        return Path(__file__).parent.parent


def setup_paths():
    """Set up Python paths for imports."""
    base_path = get_base_path()

    # Add backend to Python path
    backend_path = base_path / "backend"
    if backend_path.exists():
        sys.path.insert(0, str(backend_path))
    else:
        # In dev mode, backend is current directory's parent
        sys.path.insert(0, str(Path(__file__).parent))

    # Set working directory
    work_dir = get_work_dir()
    os.chdir(work_dir)


def copy_default_agents():
    """Copy default agents if they don't exist."""
    if not getattr(sys, "frozen", False):
        return

    base_path = get_base_path()
    work_dir = get_work_dir()

    agents_dest = work_dir / "agents"
    agents_src = base_path / "agents"
    if not agents_dest.exists() and agents_src.exists():
        import shutil

        shutil.copytree(agents_src, agents_dest)
        print(f"Default agents copied: {agents_dest}")


def is_env_configured(env_file: Path) -> bool:
    """Check if .env file has valid configuration."""
    if not env_file.exists():
        return False

    content = env_file.read_text(encoding="utf-8")

    # Check for placeholder values that indicate unconfigured state
    has_valid_hash = "API_KEY_HASH=" in content and "example_hash" not in content and "paste_your" not in content
    has_valid_jwt = "JWT_SECRET=" in content and "your-random-secret" not in content

    return has_valid_hash and has_valid_jwt


def run_first_time_setup():
    """Run interactive first-time setup wizard."""
    import bcrypt

    print("=" * 60)
    print("ClaudeWorld - Initial Setup")
    print("=" * 60)
    print()
    print("Welcome! Let's set up your application.")
    print()

    # Get password from user
    while True:
        password = getpass.getpass("Enter password: ")
        if len(password) < 4:
            print("Password must be at least 4 characters. Please try again.")
            continue

        password_confirm = getpass.getpass("Confirm password: ")
        if password != password_confirm:
            print("Passwords do not match. Please try again.")
            continue

        if len(password) < 8:
            print("\nNote: Password is less than 8 characters.")
            proceed = input("Continue? (Y/n): ").strip().lower()
            if proceed == "n":
                continue

        break

    # Generate password hash
    salt = bcrypt.gensalt()
    password_hash = bcrypt.hashpw(password.encode("utf-8"), salt).decode("utf-8")

    # Generate JWT secret
    jwt_secret = secrets.token_hex(32)

    # Get user name (optional)
    user_name = input("\nEnter display name (default: User): ").strip()
    if not user_name:
        user_name = "User"

    return {
        "password_hash": password_hash,
        "jwt_secret": jwt_secret,
        "user_name": user_name,
    }


def create_env_file(env_file: Path, config: dict):
    """Create .env file with user configuration."""
    env_content = f"""USER_NAME={config["user_name"]}
CLAUDE_AGENT_SDK_SKIP_VERSION_CHECK=true

# Database URL (SQLite by default)
DATABASE_URL=sqlite+aiosqlite:///./claudeworld.db

# Authentication (auto-generated by setup wizard)
API_KEY_HASH={config["password_hash"]}

# JWT Secret (auto-generated)
JWT_SECRET={config["jwt_secret"]}

# Memory System Mode: RECALL (on-demand) or BRAIN (automatic)
MEMORY_BY=RECALL

# Set to "true" for debug logging
DEBUG_AGENTS=false

# Enable guest login (default: true)
ENABLE_GUEST_LOGIN=true
"""

    env_file.write_text(env_content, encoding="utf-8")
    print(f"\nConfiguration saved: {env_file}")


def setup_environment() -> bool:
    """Set up environment for the bundled application. Returns True if setup was run."""
    work_dir = get_work_dir()
    env_file = work_dir / ".env"

    # Copy default agents
    copy_default_agents()

    # Check if setup is needed
    if is_env_configured(env_file):
        return False

    # Run first-time setup
    try:
        config = run_first_time_setup()
        create_env_file(env_file, config)
        print()
        print("=" * 60)
        print("Setup complete! Starting application...")
        print("=" * 60)
        print()
        return True
    except KeyboardInterrupt:
        print("\n\nSetup cancelled.")
        sys.exit(0)


def open_browser():
    """Open the browser to the application."""
    webbrowser.open(SERVER_URL)


def detect_claude_code() -> dict:
    """
    Detect if Claude Code CLI is installed and available.

    Returns:
        dict with keys:
        - installed: bool - whether Claude Code is available
        - version: str | None - version string if available
        - path: str | None - path to claude executable
    """
    result = {"installed": False, "version": None, "path": None}

    # Check if 'claude' command exists in PATH
    claude_path = shutil.which("claude")
    if not claude_path:
        # On Windows, also check common install locations
        if sys.platform == "win32":
            possible_paths = [
                Path(os.environ.get("LOCALAPPDATA", "")) / "Programs" / "claude-code" / "claude.exe",
                Path(os.environ.get("PROGRAMFILES", "")) / "claude-code" / "claude.exe",
                Path.home() / ".claude" / "bin" / "claude.exe",
            ]
            for path in possible_paths:
                if path.exists():
                    claude_path = str(path)
                    break

    if not claude_path:
        return result

    result["path"] = claude_path

    # Try to get version
    try:
        proc = subprocess.run(
            [claude_path, "--version"],
            capture_output=True,
            text=True,
            timeout=5,
            creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0,
        )
        if proc.returncode == 0:
            result["installed"] = True
            result["version"] = proc.stdout.strip() or proc.stderr.strip()
    except (subprocess.TimeoutExpired, subprocess.SubprocessError, OSError):
        # Command exists but couldn't get version - still consider it installed
        result["installed"] = True

    return result


def wait_for_server(timeout: int = 30) -> bool:
    """Wait for the server to become ready."""
    import urllib.request

    start = time.time()
    while time.time() - start < timeout:
        try:
            urllib.request.urlopen(f"{SERVER_URL}/docs", timeout=2)
            return True
        except Exception:
            time.sleep(0.3)
    return False


def hide_console_window():
    """Hide the console window on Windows (after setup wizard is done)."""
    if sys.platform != "win32":
        return
    if os.environ.get("CLAUDEWORLD_SHOW_CONSOLE", "").strip() == "1":
        return
    try:
        import ctypes

        console_hwnd = ctypes.windll.kernel32.GetConsoleWindow()
        if console_hwnd:
            SW_HIDE = 0
            ctypes.windll.user32.ShowWindow(console_hwnd, SW_HIDE)
    except Exception:
        pass


def run_server_thread(app):
    """Run uvicorn server in a background thread."""
    import uvicorn

    uvicorn.run(app, host=HOST, port=PORT, log_level="info")


def start_with_webview(app):
    """
    Start the application with a native pywebview window.

    The server runs in a background daemon thread while pywebview
    takes the main thread (required on Windows for GUI).
    When the window is closed, the process exits.
    """
    import webview

    # Start server in background thread
    server_thread = threading.Thread(target=run_server_thread, args=(app,), daemon=True)
    server_thread.start()

    # Wait for server to be ready
    print("Waiting for server to start...")
    if not wait_for_server():
        print("ERROR: Server failed to start. Falling back to browser mode.")
        start_with_browser(app)
        return

    print("Server ready. Opening application window...")

    # Hide console window now that setup is done and server is running
    hide_console_window()

    # Resolve icon path for the window
    icon_path = None
    if getattr(sys, "frozen", False):
        candidate = Path(sys._MEIPASS) / "assets" / "icon.ico"
        if candidate.exists():
            icon_path = str(candidate)

    # Create native window
    window = webview.create_window(
        "ClaudeWorld",
        SERVER_URL,
        width=1280,
        height=860,
        min_size=(800, 600),
    )

    # Start webview event loop (blocks until window is closed)
    webview.start(icon=icon_path)

    # When window closes, exit the process (server thread is daemon)
    os._exit(0)


def start_with_browser(app):
    """Start the application with the default browser (fallback mode)."""
    import uvicorn

    Timer(2.0, open_browser).start()
    uvicorn.run(app, host="0.0.0.0", port=PORT, log_level="info")


def main():
    """Main entry point."""
    # Set up paths first
    setup_paths()

    # Check for --browser flag (skip pywebview, use browser directly)
    use_browser = "--browser" in sys.argv

    # Run environment setup (including first-time wizard if needed)
    setup_was_run = setup_environment()

    # Load .env file BEFORE importing main/database modules
    # This ensures DATABASE_URL is available via os.getenv()
    from dotenv import load_dotenv

    work_dir = get_work_dir()
    env_file = work_dir / ".env"
    if env_file.exists():
        load_dotenv(env_file, override=True)

    # Detect Claude Code CLI
    claude_code_info = detect_claude_code()

    # Set environment variable for backend to use
    os.environ["CLAUDE_CODE_AVAILABLE"] = "true" if claude_code_info["installed"] else "false"
    if claude_code_info["path"]:
        os.environ["CLAUDE_CODE_PATH"] = claude_code_info["path"]

    print("=" * 60)
    print("ClaudeWorld")
    print("=" * 60)
    print()

    # Display Claude Code status
    if claude_code_info["installed"]:
        version_str = f" ({claude_code_info['version']})" if claude_code_info["version"] else ""
        print(f"Claude Code: Detected{version_str}")
    else:
        print("Claude Code: Not detected")
        print("  Install from: https://claude.ai/code")
    print()

    print(f"Server starting: {SERVER_URL}")
    print("Press Ctrl+C to stop the server")
    print()

    # Import the app directly instead of using string path
    # This works better with PyInstaller bundling
    from main import app

    # Decide how to start the application
    if use_browser:
        print("Mode: Browser (--browser flag)")
        start_with_browser(app)
    elif getattr(sys, "frozen", False):
        # Bundled mode: try pywebview for native window
        try:
            import webview  # noqa: F401

            print("Mode: Native window (pywebview)")
            start_with_webview(app)
        except ImportError:
            print("Mode: Browser (pywebview not available)")
            start_with_browser(app)
    else:
        # Development mode: use browser
        start_with_browser(app)


if __name__ == "__main__":
    main()
